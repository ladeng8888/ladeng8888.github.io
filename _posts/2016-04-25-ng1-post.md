---
layout: post
title: Angular2学习指南
---

## ES6相关

```javascript
class Hamburger {
  constructor() {
    // 这是构造器.
  }
  listToppings() {
    //这是Hamburger类的一个方法
  }
}
```

## TS相关
### 定义函数

```javascript
function add(a:number,b:number){
    return a + b;
}

add(1,3);
add(1,'3');//会报错
```

### typings
我们观察ng2的文件目录会发现里面有一个文件叫typings.json
```
{"ambientDependencies": {"es6-shim": "github:DefinitelyTyped/DefinitelyTyped/es6-shim/es6-shim.d.ts#7de6c3dd94feaeb21f20054b9f30d5dabc5efabd","jasmine": "github:DefinitelyTyped/DefinitelyTyped/jasmine/jasmine.d.ts#5c182b9af717f73146399c2485f70f1e2ac0ff2b"}}
```
使用了这个文件之后，我们在ng2里面不用需要加上类别信息。

### typescript类别信息
+ boolean(true/false)
+ number 
+ string
+ [] 数组，如果这个数组用来存数字类型的，可以用number[],如果是布尔型的，可以用boolean[]
+ {} 对象字面量
+ undefined
+ enum 枚举类型 比如{Red,Blue,Green}
+ any 可以用任何类型
+ void 

## bootstap(启动，不是指twitter的bootstrap)
在main文件中，我们需要这样初始化：

```javascript
import {Component,bootstrap} from 'angular2/angular2';
@Component({
    selector:"my-app",
    template:"<h1>Hello {{name}}</h1>"
})

class MyApp{
    constructor(){
        this.name = 'Max';
    }
}

bootstrap(MyApp);
```

## components
为了创建一个ng2应用你应该定义一组components,每一个UI组件、路由。一个应用包含一个根组件和一系列其他组件，换句话说，每个ng2会包含一棵component树。Application是根组件。
比如我们创建一个talk-cmp的组件：

```javascript
//TalkCmp.ts
@Component({
  selector: 'talk-cmp',
  directives: [FormattedRating, WatchButton, RateButton],
  templateUrl: 'talk_cmp.html'
})
class TalkCmp {
  @Input() talk: Talk;
  @Output() rate: EventEmitter;
  //...
}
```

```html
<!--talk_cmp.html-->
{{talk.title}}
{{talk.speaker}}
<formatted-rating [rating]="talk.rating"></formatted-rating>
<watch-button [talk]="talk"></watch-button>
<rate-button [talk]="talk"></rate-button>
```

一个组件有input和output属性，这二个属性可以通过decorator来定义：

```javascript
class TalkCmp{
    @Input() talk:Talk;
    @Output() rate: EventEmitter;
}
```

input和output属性是组件的暴露在外的公共api,你可以通过下列方式来调用：

```html
<talk-cmp [talk]="someExp" (rate)="eventHandler($event.rating)"></talk-cmp>
```

一个组件有模板，用来定义这个组件是如何在页面中是如何渲染：

```javascript
@Component({
    selector:"talk-cmp",
    directives:[FormattedRating,WatchButton,RateButton],
    templateUrl:"talk_cmp.html"
})
```

```html
<!--talk_cmp.html-->
{{talk.title}}
{{talk.speaker}}
<formatted-rating [rating]="talk.rating"></formatted-rating>
<watch-button [talk]="talk"></watch-button>
<rate-button [talk]="talk"></rate-button>
```

或者你可以把组件和模板写在一起：

```javascript
@Component({
  selector: 'talk-cmp',
  directives: [FormattedRating, WatchButton, RateButton],
  template: `
    {{talk.title}}
    {{talk.speaker}}
    <formatted-rating [rating]="talk.rating"></formatted-rating>
    <watch-button [talk]="talk"></watch-button>
    <rate-button [talk]="talk"></rate-button>
  `
})
```

## 生命周期钩子(Component Lifecycle)
+ ngOnChanges - 当一个input,output的属性改变的时候会触发这个方法
+ ngOnInit - 当ngOnChanges调用完了之后
+ ngDoCheck - 开发者自定义的change触发的时候
+ ngAfterContentInit - 当组件内容初始化的时候
+ ngAfterContentChecked - 当组件内容改变的时候
+ ngAfterViewInit - 每次检查组件的视图的时候触发
+ ngOnDestroy - 组件销毁之前会触发

PS.我会单独翻译官方文档上的生命周期具体执行流程

比如，我们可以这样：

```javascript
@Component({selector:"cares-about-changes"})
class CareAboutChange{
    @Input()field1;
    @Input()field2;
    onChange(changes){

    }
}
```

```java
// Annotation section
@Component({
  selector: 'street-map',
  template: '<map-window></map-window><map-controls></map-controls>',
})
// Component controller
class StreetMap {
  ngOnInit() {
    // Properties are resolved and things like
    // this.mapWindow and this.mapControls
    // had a chance to resolve from the
    // two child components <map-window> and <map-controls>
  }
  ngOnDestroy() {
    // Speak now or forever hold your peace
  }
  ngDoCheck() {
    // Custom change detection
  }
  ngOnChanges(changes) {
    // Called right after our bindings have been checked but only
    // if one of our bindings has changed.
    //
    // changes is an object of the format:
    // {
    //   'prop': PropertyUpdate
    // }
  }
  ngAfterContentInit() {
    // Component content has been initialized
  }
  ngAfterContentChecked() {
    // Component content has been Checked
  }
  ngAfterViewInit() {
    // Component views are initialized
  }
  ngAfterViewChecked() {
    // Component views have been checked
  }
}
```
## providers
组件可以注入很多providers
```javascript
@Component({
    selector:"conf-app",
    providers:[ConfAppBackend,Logger]
})
class TalksApp{

}
class TalksApp{

}
class TalksCmp{
    constructor(backend:ConfAppBackend){

    }
}
```

## components是自我描述的
+ 组件知道如何和宿主元素交互
+ 组件知道如何渲染自身
+ 组件配置依赖注入
+ 组件有自定义的input和output的属性

## zone.js
ng2内置了zone.js,不再需要一堆的scope.$apply代码

## Annotations

```javascript
@Component({
  selector: 'tabs'
})
@View({
  template: `
    <ul>
      <li>Tab 1</li>
      <li>Tab 2</li>
    </ul>
  `
})
export class Tabs {

}
```

@view的使用使得我们可以期待不远的将来我们可以让ng2支持ios和android原生的开发。

## 事件

```javascript
import {Component} from 'angular2/core';

@Component({
  selector: 'counter',
  template: `
    <div>
      <p>Count: {{ num }}</p>
      <button (click)="increment()">Increment</button>
    </div>
  `
})
export class Counter {
  num: number = 0;

  increment() {
    this.num++;
  }
}
```

## 双向数据绑定

```javascript
<input [(ngModel)]="name" >

```

## Projection

```javascript
import {Component, Input} from 'angular2/core';

@Component({
  selector: 'child',
  template: `
    <h4>Child Component</h4>
    <ng-content></ng-content>
  `
})
class Child {}
```

